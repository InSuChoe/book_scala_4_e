package _7_builtIn_control_syntax._7_4_try_catch_finally

import java.io.{FileNotFoundException, FileReader, IOException};
//  n이 짝수이면 half에는 n의 반에 해당하는 값이 들어간다.
//  만일 n이 짝수가 아니면 어떤 값으로도 초기화하지 않고,
//  그 전에 예외를 발생시킨다.
//
//  그렇기 때문에, else 부분에서 어떤 예외를 던지더라도
//  이를 원하는 타입으로 다뤄도 아무 문제가 없다.
//
//  어차피 어떤 문맥내에서 throw가 던지는 예외를 사용하려 해도
//  결과(예외)를 사용할 수 있는 경우는 없기 때문에,
//  이렇게 타입을 처리해도 아무 문제가 없다.
//
//  기술적으로 말하면, 예외는 Nothing이라는 타입을 갖는다.
//  따라서 비록 어떤 값을 만들어내는 일은 없지만 throw를 표현식처럼 사용할 수 있다.
//  이런 기술적으로 약간 어려운 세부사항이 이상하게 들릴지 모르겠지만,
//  앞서 살펴본 예와 같이 유용한 경우가 종종 있다.
//
//  코드의 한쪽 분기는 어떤 값을 계산하는 반면,
//  다른 쪽 분기에서는 예외를 발생시키면서 결과가 Nothing 타입이다.
//  이런 경우 무언가를 계산하는 분기의 결과 타입이 if 표현식 전체의 타입이다.

// (앞 문단에서 설명했지만,
//  Nothing이 결끈값의 타입이라고 해도 이 결과를 실제로 써먹는 경우는 없다.
//  예외가 발생한다면 결끗값을 돌려주기도 전에 제어 흐름이 호출한 쪽으로 넘어간다.
//  throw를 표현식으로 다루고 Nothing으로 타입을 지정하는 것은
//  단지 throw 문을 식으로 만들고 타입 시스템(스칼라의 지역 타입 추론 기능)에도 잘 들어맞게 해서,
//  스칼라 프로그램 안에서 자유롭게 throw를 쓸 수 있게 하기 위한 기술적 장치일 뿐이다.
//  예를 들면, if문의 두 코드 분기는 모두 표현식이어야 한다.
//  만약 throw 문만 특별한 취급을 한다면
//  이런저런 문법 구조나 컴파일러 처리가 복잡해질 수도 있다.
//  그래서 throw 문도 표현식으로 취급하고,
//  특별한 타입(모든 타입의 하위 타입인 Nothing)을 부여해
//  서 자연스럽게 전체 문법이 조화를 이루게 만드는 편을 스칼라 설계자가 택한 것이다. - 옮긴이)
//  Nothing에 대한 내용은 11.3절에서 좀 더 자세히 살펴본다.

//  발생한 예외 잡기
//
//  리스트 7.11과 같은 문법을 이용해 발생한 예외를 잡는다.
//
//  catch 절의 문법은 스칼라의 중요한 부분을 차지하는 패턴 매치 pattern match
//  와의 일관성을 유지하기 위해 예제와 같은 형태를 채용했다.
//  패턴 매치는 강력한 기능이다. 여기서 간략하게 설명하고,
//  다시 15장에서 자세히 다룰 것이다.

//  리스트 7.11 스칼라로 작성한 try-catch 절
object _7_11 {
  def main(args: Array[String]): Unit = {
    try {
      val f = new FileReader("input.txt")
    } catch {
      case ex : FileNotFoundException => // 파일을 처리하지 못 하는 경우
      case ex : IOException =>  // 그 밖의 IO 처리
    }
  // 파일을 사용하고 닫는다.
  }

}
