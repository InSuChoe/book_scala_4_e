package _7_1
//  스칼라가 제공하는 내장 제어 구문은 몇 가지 없다.
//  if, while, for, try, match, 함수 호출 function cal 이 전부다.
//  스칼라에 제어 구문의 수가 적은 이유는 설계 초기부터 함수 리터럴 을 포함했기 때문이다.
//  스칼라는 기본 문법에서 제어 구문 위에 다른 제어 구문을 하나하나 추가하기보다는
//  라이브러리에 제어 구문을 추가하는 편을 택했다
//  (9장에서는 정확히 그 와 같은 내용이 어떻게 이뤄지는지 알아볼 것이다).
//  7장에서는 그 기반이 될 내장 제어 구문을 살펴본다.

//  곧 알게 되겠지만, 스칼라의 제어 구문은 대부분 어떤 값을 결과로 내놓는다.
//  이는 프로그램 전체를 값을 계산하는 관점에서 바라보고
//  프로그램 구성요소 또한 값을 도출해야 한다는 함수 언어적 접근을 채용한 결과다.
//  이런 접근 방법은 명령형 언어에도 이미 존재하는 경향의 논리적 귀결이기도 하다.
//  명령형 언어에서는 함수가 자신이 받은 인자를 직접 변경해
//  결과를 전달하는 방식이 잘 동작함에도 불구하고
//  함수가 값을 반환하는 형태를 사용한다.

//  추가로 명령형 언어에서는 C, C++, 자바의 ?: 과 같이,
//  if 와 동일하지만 값을 결과로 반환하는 삼항 연산자도 종종 볼 수 있다.
//  스칼라에서는 삼항 연산자 모델을 채용하되,
//  삼항 연산자와 if를 합쳐서 if 구문으로만 사용한다.
//  다시 말해, 스칼라의 if는 값을 결과로 내놓을 수 있다.
//  스칼라는 이러한 방식을 for. try, match에도 적용했다.
//  이들은 모두 결과로 값을 내놓는다.

//  프로그래머는 이러한 결팟값 반환을 이용해 함수의 반환값을 이용하듯 코드를 간단하게 만들 수 있다.
//  이러한 기능이 없다면 프로그래머가 직접 임시 변수를 만들어 계산한 값을 저장해야 한다.
//  임시 변수를 없애면 코드가 약간 더 간단해지며,
//  특정 변수를 일부 분기 코드에만 설정하고 다른 분기에는 설정하지 않는 등의 여러 가지 버그를 방지할 수 있다.
//
//  결국, 스칼라의 기본 제어 구문은 최소한의 요소를 갖췄지만 명령형 언어에서 핵심적인 개념을 모두 제공한다.
//  게다가, 값을 반환함으로써 코드를 더욱 짧게 만들 수 있다.
//  어떻게 그럴 수 있는지 기본 제어 구문을 자세히 알아보자.

//  스칼라의 if는 다른 여러 언어와 마찬가지로 동작한다. 조건을 테스트하고 결과가 참인
//  지 여부에 따라 2개의 코드 분기 중 하나를 실행한다. 명령형 스타일로 작성한 코드의 예
//  는 다음과 같다.
object _7_1 {
  def main(args: Array[String]): Unit = {
    var filename = "default.txt"
    if (!args.isEmpty)
      filename = args(0)
    println(filename)
  }
}
