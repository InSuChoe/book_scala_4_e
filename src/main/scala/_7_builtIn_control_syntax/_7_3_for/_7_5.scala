package _7_builtIn_control_syntax._7_3_for

//  일반적으로, while 루프는 var 변수를 사용할 때와 마찬가지로
//  최대한 이를 적게 사용하기 위해 노력할 것을 권장한다.
//  사실 while 루프와 var 변수를 함께 사용하는 경우가 많다.
//  while 루프는 결과로 값을 내놓지 않기 때문에,
//  프로그램에 어떤 변화를 주려면 I/O를 수행하거나 var 변수를 갱신해야만 한다.
//  gcdLoop 예제에서 이와 같은 내용을 확인했다.
//  while 루프는 역할을 다하며 a와 b 변수(var)를 갱신한다.
//  따라서 while 루프를 꼭 사용해야 하는지 의심해보기를 권한다.
//  특별히 while이나 do-while 루프를 사용할 충분히 정당한 이유가 없다면,
//  이런 루프를 사용하지 않고 문제를 해결할 방법을 찾아보라.

//  스칼라의 for 표현식은 반복 처리를 위한 스위스 만능 칼이라 할 수 있다.
//  몇 가지 간단한 재료를 여러 가지 방법으로 조합해 다양한 반복 작업을 처리할 수 있다.
//  연속적인 정수를 이터레이션하는 일과 같이 일반적인 작업을 처리하는 것은 간단한 방법으로도 가능하며,
//  여러 종류의 컬렉션을 이터레이션하며 조건에 맞는 요소를 가려내고
//  새로운 컬렉션을 만드는 등의 고급 표현도 가능하다.

//  컬렉션 이터레이션

//  for 로 할 수 있는 가장 간단한 일은 컬렉션에 있는 모든 요소를 이터레이션하는 것이다.
//  예를 들면, 리스트 7.5는 현재 디렉토리의 모든 파일을 출력하는 코드다.
//  I/O에는 자바API를 사용한다.
//  첫째로, 현재 디렉토리 "."에 대한 java.io.File을 생성하고 listFiles 메서드를 호출한다.
//  listFiles 를 호출하면 현재 디렉토리 내 파일과 디렉토리를 내용으로 하는 File 객체의 배열을 얻는다.
//  filesHere 변수에 결과 배열을 저장한다.

//리스트 7.5 for 표현식으로 디렉토리 내 파일의 목록 구하기
object _7_5 {
  def main(args: Array[String]): Unit = {
    val filesHere = (new java.io.File(".")).listFiles()

    for(file <- filesHere)
      println(file)
  }
}
